# 実装計画: [FEATURE]

**ブランチ**: `[###-feature-name]` | **日付**: [DATE] | **仕様**: [link]  
**入力**: `/specs/[###-feature-name]/spec.md` のフィーチャ仕様

**メモ**: `/speckit.plan` コマンドが本テンプレートを出力する。運用手順はリポジトリのドキュメントで最新状態を確認する。

## サマリー

[仕様からの抜粋: 主要求と調査で決定した技術アプローチを要約する]

## 技術コンテキスト

**使用言語 / バージョン**: Node.js LTS + TypeScript/JavaScript（不明な場合は要確認と記載）  
**主要依存関係**: 例) Express, NestJS, Prisma（未確定なら要確認）  
**ストレージ**: 例) PostgreSQL, DynamoDB, ファイル, N/A  
**テスト基盤**: 例) Jest, Vitest, Playwright（不足時は要確認）  
**対象プラットフォーム**: 例) Linux サーバー, AWS Lambda など  
**プロジェクト種別**: 単一リポジトリ / Web / モノレポなど  
**性能目標**: ドメインに依存。例) p95 < 200ms, 100rq/s  
**制約**: ドメイン / 法規制 / インフラ制約を列挙  
**規模・スコープ**: 想定ユーザー数やユースケース範囲

## 憲章準拠チェック

*ゲート条件: フェーズ0（リサーチ）着手前とフェーズ1（設計）完了時に必ず確認する。*

- ドメイン中心アーキテクチャ: 依存方向が `interfaces → application → domain` のみになっているか。
- 仕様駆動の意思決定: `/specs/` の仕様に受入基準・制約・ドメイン影響が記載されているか。
- ユースケース単位のモジュール性: 対象ユースケースが独立実装・独立デプロイ可能な粒度か。
- テストファースト検証: 必要なテスト種別（単体・契約・統合）が洗い出され、タスク化されているか。
- ドキュメント同期と追跡性: 本計画と仕様・タスク間のリンクが存在し、更新フローが明示されているか。
- ドメインモデル開発手順: ドメイン→インメモリリポジトリ→ユースケース→アダプタ→統合テストの順序が維持されているか。
- クリーンアーキテクチャ構造: 層ごとの責務と依存方向（`interfaces → application → domain`）が守られ、横断的関心事はインフラストラクチャ層に限定されているか。
- CQRS/Event Sourcing: コマンド・クエリ分離、イベントストア構成、`@j5ik2o/event-store-adapter-js` の利用計画が定義されているか。
- エラーハンドリング戦略: 回復可能性に基づき戻り値型（Either/Result 等）と例外使用境界が定義されているか。

## プロジェクト構成

### ドキュメント（このフィーチャ）

```text
specs/[###-feature]/
├── plan.md              # 本テンプレート（/speckit.plan 出力）
├── research.md          # フェーズ0成果物（/speckit.plan 出力）
├── data-model.md        # フェーズ1成果物（/speckit.plan 出力）
├── quickstart.md        # フェーズ1成果物（/speckit.plan 出力）
├── contracts/           # フェーズ1成果物（/speckit.plan 出力）
└── tasks.md             # フェーズ2成果物（/speckit.tasks 出力。/speckit.plan では生成しない）
```

### ソースコード（リポジトリルート）

```text
src/
├── domain/
│   ├── entities/
│   ├── value-objects/
│   └── services/
├── application/
│   ├── use-cases/
│   └── ports/
└── interfaces/
    ├── http/
    ├── cli/
    ├── persistence/
    └── event/

projections/
├── read-models/
└── subscribers/

infrastructure/
├── logging/
├── config/
└── utilities/

tests/
├── unit/         # ドメイン・ユースケース単体
├── contract/     # ポート・アダプタ契約
└── integration/  # ユースケース横断
```

**構成方針**: [このフィーチャで利用する実際のディレクトリ構成と差分を説明する]

## ドメインモデル開発計画

1. **ドメインテスト**: [作成するテストスイートとカバーするエッジケースを列挙する]
2. **モデル実装**: [値オブジェクト・エンティティ・集約で扱う不変条件や振る舞いを記述する]
3. **リファクタリング**: [責務整理・命名統一の観点を示す]
4. **インメモリリポジトリ**: [テスト用リポジトリの実装方針と扱う操作を明記する]
5. **ユースケース実装**: [実装順と必要なポート・サービス・エラー処理を説明する]
6. **アダプタ実装**: [永続化・API・UI など外部との接続順序を定義する]
7. **統合・結合テスト**: [使用するインフラ・テスト範囲・成功判定基準を記述する]

## エラーハンドリング計画

- **回復可能エラー**: [Either/Result 等で返却するエラー種別、ユースケースでの対処方法（リトライ・代替フロー・通知）]
- **回復不能エラー**: [例外/ panic を使用する箇所と根拠、ログ・監視の方法]
- **例外変換方針**: [インフラ層で捕捉しドメイン向け型へ変換するルール]
- **命名規則**: [エラー型の命名および責務]

## CQRS/Event Sourcing 設計

- **コマンドモデル**: [ハンドラ、集約、コマンド名、整合性制約、ユースケースとの関連]
- **クエリモデル**: [リードモデル、投影更新方式、最終的整合性の扱い。ドメインモデル・リポジトリを使用せずリードデータベースへ直接アクセスする設計]
- **イベントスキーマ**: [イベント名、ペイロード、バージョニング/アップキャスト方針]
- **イベントストア構成**: [`@j5ik2o/event-store-adapter-js` の接続設定、ストリーム命名規約、スナップショット]
- **運用・テスト**: [イベントリプレイ、障害時の復旧手順、負荷試験計画]

## リファレンス資産の活用

- **イベントストア実装**: `references/event-store-adapter-js` のどのモジュール・設定を参照するかを記述し、コードコピーを行わず設計意図のみ取り込むことを明示。
- **CQRS サンプル**: `references/cqrs-es-example-js` のコマンド/クエリ/投影の参照箇所と、本計画との違い・対応策を明示（参照のみでありコピー禁止）。
- **ライセンス対応**: 取り込むコードのライセンス表記方法と改変内容の記録方法。
- **レビュー観点**: リファレンスとの差異をレビューで検証するチェック項目。

## 複雑性トラッキング

> **憲章準拠チェックで違反がある場合のみ記入する。**

| 違反内容 | 必要な理由 | 却下した単純代替案と理由 |
|----------|------------|----------------------------|
| [例: 追加レイヤー導入] | [必要性] | [採用しなかった代替案] |
## レイヤー責務確認

- **ドメイン層**: [扱うエンティティ・値オブジェクト・ドメインサービスと、ドメインサービスが純粋関数であり外部依存を持たないことを明記]
- **ユースケース層**: [実装予定のアプリケーションサービス、依存するポート、イベントやフロー制御の設計]
- **インターフェースアダプタ層**: [コントローラ・ゲートウェイ・リポジトリ実装、外部システムとの変換方針]
- **インフラストラクチャ層**: [提供する共通ユーティリティ（ロギング・ID生成・設定など）と IO を持たない証跡。RPC やデータベースアクセスを実装しない旨を明記]
